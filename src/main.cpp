
#include <Arduino.h>
#include <ESP32WifiCLI.hpp>
#include <LightningSensor.h>
#include <PubSubClient.h>
#include <String.h>
#include <WiFi.h>
#include <WiFiClient.h>
#include <arduino-timer.h>
#include <StormFrontDistance.h>
#include <ArduinoJson.h>
#include <StreamUtils.h>
#include <DateTime.h>
#include <SensorSettings.h>
#include <SystemSettings.h>

// Plucked from /usr/share/i18n/locales/en_US on a local linux box
// % Appropriate date and time representation (%c)
// d_t_fmt "%a %d %b %Y %r %Z"
const char* DEFAULT_DATETIME_FORMAT = "%a %d %b %Y %r %Z";

// Cloud art under ISC License ripped from https://github.com/schachmat/wego/blob/bf192ea66e771a8031117845bfa04c603f903f41/frontends/ascii-art-table.go#L258
// BZZT block element ASCII Art generated by https://patorjk.com/software/taag/#p=display&f=ANSI%20Regular&t=BZZT
// Contains color control codes for any competent terminal program.
/*
     .-.        ██████  ███████ ███████ ████████
    (   ).      ██   ██    ███     ███     ██
   (___(__)     ██████    ███     ███      ██
  ‚ʻ⚡ʻ‚⚡‚ʻ    ██   ██  ███     ███       ██
  ‚ʻ‚ʻ⚡ʻ‚ʻ     ██████  ███████ ███████    ██
*/
const char logo[] =
  "                                                                           \r\n"
  "\033[38;5;244;1m     .-.     \033[0m   ██████  ███████ ███████ ████████\r\n"
  "\033[38;5;244;1m    (   ).   \033[0m   ██   ██    ███     ███     ██\r\n"
  "\033[38;5;244;1m   (___(__)  \033[0m   ██████    ███     ███      ██\r\n"
  "\033[38;5;33;1m  ‚ʻ\033[38;5;228;5m⚡\033[38;5;33;25mʻ‚\033[38;5;228;5m⚡\033[38;5;33;25m‚ʻ   \033[0m ██   ██  ███     ███       ██\r\n"
  "\033[38;5;33;1m  ‚ʻ‚ʻ\033[38;5;228;5m⚡\033[38;5;33;25mʻ‚ʻ   \033[0m  ██████  ███████ ███████    ██\r\n"
  "                                                                           \r\n"
  "\n"
  "";

SensorSettings sensorSettings;
SensorPreferences sensorPreferences;
SystemSettings systemSettings;
SystemPreferences systemPreferences;
LightningSensor sensor;
WiFiClient wifiClient;
PubSubClient mqtt(wifiClient);

Timer<> timer = timer_create_default(); // create a timer with default settings

#pragma region "Error Visibility"
bool toggleErrorLed(void *)
{
  static bool state = false;

  state = !state;
  neopixelWrite(LED_BUILTIN, state ? RGB_BRIGHTNESS : 0, 0, 0);

  return true;
}

void setErrorStatus(bool isErrored = true)
{
  static Timer<>::Task error_task = 0;

  if (isErrored)
  {
    if (error_task == 0)
    {
      error_task = timer.every(500, toggleErrorLed);
    }
  }
  else
  {
    if (error_task != 0)
    {
      timer.cancel(error_task);
      error_task = 0;
    }
  }
}
#pragma endregion

#pragma region "MQTT Management"
void checkSensor()
{
  // Run the interrupt check every loop for faster latency.
  // We miss later strikes if more of them happen right after we process the first one.
  if (sensor.isTriggered()) {
    SensorEvent event;
    sensor.getSensorEvent(&event);

    if (mqtt.connected())
    {
      StaticJsonDocument<256> doc;

      doc["type"] = statusToString(event.type);
      doc["distance"] = event.distance;
      doc["energy"] = event.energy;

      DateTimeParts timestampParts = DateTimeParts::from(event.timestamp.tv_sec);
      String timestamp = String(timestampParts.format("%FT%T"));
      timestamp.concat('.');
      char microseconds[7] = { 0, };
      snprintf(microseconds, 6, "%d", event.timestamp.tv_usec);
      timestamp.concat(microseconds);
      timestamp.concat(timestampParts.format("%z"));

      doc["timestamp"] = timestamp;

      String stateTopic = "lightning/bzzt_";
      char mac[17] = { 0, };

      snprintf(mac, sizeof(mac), "%016llx", ESP.getEfuseMac());
      stateTopic.concat(mac);
      stateTopic.concat("/event");

      mqtt.beginPublish(stateTopic.c_str(), measureJson(doc), false);
      BufferingPrint bufferedClient(mqtt, 32);
      serializeJson(doc, bufferedClient);
      bufferedClient.flush();
      mqtt.endPublish();
      setErrorStatus(false);
    }
    else
    {
      setErrorStatus(true);
    }
  }
}

bool discovery(void *) {
  StaticJsonDocument<1024> config;
  String discoveryTopic = "homeassistant/device/bzzt_";
  String identifier = "bzzt_";
  char mac[17] = { 0, };

  snprintf(mac, sizeof(mac), "%016llx", ESP.getEfuseMac());
  identifier.concat(mac);
  discoveryTopic.concat(mac);
  discoveryTopic.concat("/config");

  if (mqtt.connected()) {
    JsonObject device = config["device"].to<JsonObject>();
    device["identifiers"][0] = identifier;
    device["name"] = "BZZT";
    config["origin"]["name"] = "bzzt2mqtt";

    JsonObject components = config["components"].to<JsonObject>();
    // Interrupt Type
    JsonObject cmpType = components["bzzt_type"].to<JsonObject>();
    cmpType["platform"] = "sensor";
    cmpType["name"] = "Lightning Type";
    cmpType["device_class"] = "enum";

    JsonArray cmpTypeOptions = cmpType["options"].to<JsonArray>();
    cmpTypeOptions.add(statusToString(INTERRUPT_STATUS::LIGHTNING));
    cmpTypeOptions.add(statusToString(INTERRUPT_STATUS::DISTURBER_DETECT));
    cmpTypeOptions.add(statusToString(INTERRUPT_STATUS::NOISE_TO_HIGH));
    cmpTypeOptions.add(statusToString(0)); // No Event

    cmpType["value_template"] = "{{ value_json.type }}";
    String typeId = String(identifier);
    typeId.concat("_i");
    cmpType["unique_id"] = typeId;

    // Lightning Distance
    JsonObject cmpDistance = components["bzzt_distance"].to<JsonObject>();
    cmpDistance["platform"] = "sensor";
    cmpDistance["name"] = "Lightning Distance";
    cmpDistance["device_class"] = "distance";
    cmpDistance["unit_of_measurement"] = "km";
    cmpDistance["value_template"] = "{{ value_json.distance }}";
    String distanceId = String(identifier);
    distanceId.concat("_d");
    cmpDistance["unique_id"] = distanceId;

    // A 20 bit value that is the 'energy' of the lightning strike.
    // This is only a pure value that doesn't have any physical meaning.
    JsonObject cmpEnergy = components["bzzt_energy"].to<JsonObject>();
    cmpEnergy["platform"] = "sensor";
    cmpEnergy["name"] = "Lightning Energy";
    cmpEnergy["value_template"] = "{{ value_json.energy }}";
    String energyId = String(identifier);
    energyId.concat("_e");
    cmpEnergy["unique_id"] = energyId;

    // A unix timestamp with fractional seconds of exactly when the strike happened.
    JsonObject cmpTimestamp = components["bzzt_timestamp"].to<JsonObject>();
    config["components"]["bzzt_timestamp"] = cmpTimestamp;
    cmpTimestamp["platform"] = "sensor";
    cmpTimestamp["name"] = "Lightning Timestamp";
    cmpTimestamp["device_class"] = "timestamp";
    cmpTimestamp["value_template"] = "{{ value_json.timestamp }}";
    String timestampId = String(identifier);
    timestampId.concat("_t");
    cmpTimestamp["unique_id"] = timestampId;

    String stateTopic = "lightning/bzzt_";
    stateTopic.concat(mac);
    stateTopic.concat("/event");

    config["state_topic"] = stateTopic;

    mqtt.beginPublish(discoveryTopic.c_str(), measureJson(config), false);
    BufferingPrint bufferedClient(mqtt, 32);
    serializeJson(config, bufferedClient);
    bufferedClient.flush();
    mqtt.endPublish();

    setErrorStatus(false);
  } else {
    setErrorStatus(true);
  }

  return true; // Should timer task repeat? true
}

void onPubSubCallback(char *topic, byte *payload, unsigned int length)
{
  if (strcmp(topic, "lightning/ping") == 0)
  {
    StringPrint stream;
    stream.printf("Cores: %u\n", ESP.getChipCores());
    stream.printf("Model: %s\n", ESP.getChipModel());
    stream.printf("Revision: %u\n", ESP.getChipRevision());
    stream.printf("IP: %s\n", WiFi.localIP().toString().c_str());

    mqtt.publish("lightning/pong", stream.str().c_str(), false);
  }
}
#pragma endregion

#pragma region "Wifi CLI Callbacks"
class mESP32WifiCLICallbacks : public ESP32WifiCLICallbacks
{
    // This method is run by wcli.loop() every 1000 millseconds
    void onWifiStatus(bool isConnected)
    {
      if (isConnected)
      {
        if (!mqtt.connected())
        {
          if (!systemSettings.brokerHostname.isEmpty())
          {
            mqtt.setServer(systemSettings.brokerHostname.c_str(), 1883);
            mqtt.setCallback(onPubSubCallback);

            if (mqtt.connect(systemSettings.systemHostname.c_str()) && mqtt.subscribe("lightning/ping"))
            {
              setErrorStatus(false);
            }
            else
            {
              setErrorStatus(true);
            }
          }

        }

        if (!DateTime.isTimeValid()) {
          DateTime.setTimeZone("UTC0");
          DateTime.setServer(systemSettings.timeServer1.c_str(), systemSettings.timeServer2.c_str(), systemSettings.timeServer3.c_str());

          /*
            The Espressif SDK uses the lwIP SNTP library internally.
            Any application that initializes the SNTP service periodically synchronizes the time.
            The time synchronization period is determined by CONFIG_LWIP_SNTP_UPDATE_DELAY (the default value is one hour).

            https://docs.espressif.com/projects/esp-idf/en/latest/esp32s3/api-reference/system/system_time.html#sntp-time-synchronization
          */
          DateTime.begin();
        }

        neopixelWrite(LED_BUILTIN, 0, RGB_BRIGHTNESS, 0);
      }
      else
      {
        neopixelWrite(LED_BUILTIN, 0, 0, RGB_BRIGHTNESS);
      }
    }

    void onHelpShow()
    {

    }

    void onNewWifi(String ssid, String passw) { }
};

void reboot(char *args, Stream *response) {
  wcli.shell->clear();
  wcli.client->stop();
  ESP.restart();
}

void printCurrentDate(char *args, Stream *response) {
  if (DateTime.isTimeValid()) {
    String currentTime = DateTime.format(DEFAULT_DATETIME_FORMAT);
    response->printf("The system clock is valid.\n%s\n", currentTime.c_str());
  } else {
    response->println("The system clock is not valid.");
  }

}

void clearStorage(char *args, Stream *response) {
  wcli.clearSettings();
  sensorPreferences.clear();
  systemPreferences.clear();

  response->println("All settings cleared!");
}

void saveSettings(char *args, Stream *response) {
  sensorPreferences.save(&sensorSettings);
  systemPreferences.save(&systemSettings);
}

void setSetting(char *args, Stream *response) {
  Pair<String, String> operands = wcli.parseCommand(args);

  String argName = operands.first();

  if (argName.isEmpty()) {
    response->println("Missing argument <name>");

    response->println("\nValid Names:");
    response->println("\tbrokerHostname");
    response->println("\tsystemHostname");
    response->println("\ttimeServer1");
    response->println("\ttimeServer2");
    response->println("\ttimeServer3");
    response->println("\tsensorLocation");
    response->println("\ttuningCapacitor");
    response->println("\tlightningThreshold");
    response->println("\twatchdogThreshold");
    response->println("\tnoiseFloor");
    response->println("\tspikeRejection");
    response->println("\treportDisturber");

    return;
  }

  String argValue = operands.second();

  if (argName.equalsIgnoreCase("brokerHostname")) {
    String argVal = wcli.parseArgument(args);

    argVal.trim();
  
    if (argVal.length() == 0) {
      response->println("Missing argument <BROKER_HOSTNAME>");
      return;
    }
  
    systemSettings.brokerHostname = argVal;
    response->println("\nMQTT broker set to " + argVal);
    response->println("Please save and reboot to apply the change.");

    return;
  }

  if (argName.equalsIgnoreCase("systemHostname")) {
    String argVal = wcli.parseArgument(args);

    argVal.trim();
  
    if (argVal.length() == 0) {
      response->println("Missing argument <SYSTEM_HOSTNAME>");
      return;
    }
  
    systemSettings.systemHostname = argVal;
    response->println("\nSystem hostname set to " + argVal);
    response->println("Please save and reboot to apply the change.");

    return;
  }

  if (argName.equalsIgnoreCase("timeServer1")) {
    String argVal = wcli.parseArgument(args);

    argVal.trim();
  
    if (argVal.length() == 0) {
      response->println("Missing argument <TIMESERVER1>");
      return;
    }
  
    systemSettings.timeServer1 = argVal;
    response->println("\nFirst timeserver set to " + argVal);
    response->println("Please save and reboot to apply the change.");

    return;
  }

  if (argName.equalsIgnoreCase("timeServer2")) {
    String argVal = wcli.parseArgument(args);

    argVal.trim();
  
    if (argVal.length() == 0) {
      response->println("Missing argument <TIMESERVER2>");
      return;
    }
  
    systemSettings.timeServer2 = argVal;
    response->println("\nSecond timeserver set to " + argVal);
    response->println("Please save and reboot to apply the change.");

    return;
  }

  if (argName.equalsIgnoreCase("timeServer3")) {
    String argVal = wcli.parseArgument(args);

    argVal.trim();
  
    if (argVal.length() == 0) {
      response->println("Missing argument <TIMESERVER3>");
      return;
    }
  
    systemSettings.timeServer3 = argVal;
    response->println("\nThird timeserver set to " + argVal);
    response->println("Please save and reboot to apply the change.");

    return;
  }

  if (argName.equalsIgnoreCase("sensorLocation")) {
    if (argValue.isEmpty()) {
      response->println("Missing argument <value>");
      return;
    }

    if (argValue.equalsIgnoreCase("INDOOR")) {
      sensorSettings.sensorLocation = INDOOR;
    } else if (!argValue.equalsIgnoreCase("OUTDOOR")) {
      sensorSettings.sensorLocation = OUTDOOR;
    } else {
      response->println("Invalid argument <value>: You must enter either indoor or outdoor.");
      return;
    }

    SparkFun_AS3935 rawSensor = sensor.getSensor();
    rawSensor.setIndoorOutdoor(sensorSettings.sensorLocation);

    return;
  }

  if (argName.equalsIgnoreCase("tuningCapacitor")) {
    if (argValue.isEmpty()) {
      response->println("Missing argument <value>");
      return;
    }

    int value = argValue.toInt();
    if (value < 0 || value > 120) {
      response->println("Invalid argument <value>: You must enter a number between 0 and 120.");
      return;
    }

    if (value % 8 != 0) {
      response->println("Invalid argument <value>: You must enter a number divisible by 8.");
      return;
    }

    sensorSettings.tuningCapacitor = (uint8_t) value;

    SparkFun_AS3935 rawSensor = sensor.getSensor();
    rawSensor.tuneCap(sensorSettings.tuningCapacitor);

    return;
  }

  if (argName.equalsIgnoreCase("lightningThreshold")) {
    if (argValue.isEmpty()) {
      response->println("Missing argument <value>");
      return;
    }

    int value = argValue.toInt();
    if (value != 1 && value != 5 && value != 9 && value != 16) {
      response->println("Invalid argument <value>: You must enter 1, 5, 9, or 16.");
      return;
    }

    sensorSettings.lightningThreshold = (uint8_t) value;

    SparkFun_AS3935 rawSensor = sensor.getSensor();
    rawSensor.lightningThreshold(sensorSettings.lightningThreshold);

    return;
  }

  if (argName.equalsIgnoreCase("watchdogThreshold")) {
    if (argValue.isEmpty()) {
      response->println("Missing argument <value>");
      return;
    }

    int value = argValue.toInt();
    if (value < 0 || value > 10) {
      response->println("Invalid argument <value>: You must enter a number between 0 and 10.");
      return;
    }

    sensorSettings.watchdogThreshold = (uint8_t) value;

    SparkFun_AS3935 rawSensor = sensor.getSensor();
    rawSensor.watchdogThreshold(sensorSettings.watchdogThreshold);

    return;
  }

  if (argName.equalsIgnoreCase("noiseFloor")) {
    if (argValue.isEmpty()) {
      response->println("Missing argument <value>");
      return;
    }

    int value = argValue.toInt();
    if (value < 1 || value > 7) {
      response->println("Invalid argument <value>: You must enter a number between 1 and 7.");
      return;
    }

    sensorSettings.noiseFloor = (uint8_t) value;

    SparkFun_AS3935 rawSensor = sensor.getSensor();
    rawSensor.setNoiseLevel(sensorSettings.noiseFloor);

    return;
  }

  if (argName.equalsIgnoreCase("spikeRejection")) {
    if (argValue.isEmpty()) {
      response->println("Missing argument <value>");
      return;
    }

    int value = argValue.toInt();
    if (value < 1 || value > 11) {
      response->println("Invalid argument <value>: You must enter a number between 1 and 11.");
      return;
    }

    sensorSettings.spikeRejection = (uint8_t) value;

    SparkFun_AS3935 rawSensor = sensor.getSensor();
    rawSensor.spikeRejection(sensorSettings.spikeRejection);

    return;
  }

  if (argName.equalsIgnoreCase("reportDisturber") == 1) {
    if (argValue.isEmpty()) {
      response->println("Missing argument <value>");
      return;
    }

    int value = argValue.toInt();
    if (value < 0 || value > 1) {
      response->println("The value argument must be 1 or 0, indicating true or false respectively.");
      return;
    }

    sensorSettings.reportDisturber = (bool) value;

    SparkFun_AS3935 rawSensor = sensor.getSensor();
    rawSensor.maskDisturber(!sensorSettings.reportDisturber);

    return;
  }

  response->println("Setting name not recognized.");
}

void getSetting(char *args, Stream *response) {
  Pair<String, String> operands = wcli.parseCommand(args);

  String argName = operands.first();

  if (argName.isEmpty()) {
    response->println("Missing argument <name>");

    response->println("\nValid Names:");
    response->println("\tbrokerHostname");
    response->println("\tsystemHostname");
    response->println("\ttimeServer1");
    response->println("\ttimeServer2");
    response->println("\ttimeServer3");
    response->println("\tsensorLocation");
    response->println("\ttuningCapacitor");
    response->println("\tlightningThreshold");
    response->println("\twatchdogThreshold");
    response->println("\tnoiseFloor");
    response->println("\tspikeRejection");
    response->println("\treportDisturber");

    return;
  }

  if (argName.equalsIgnoreCase("brokerHostname")) {
    response->printf("brokerHostname: %s\n", systemSettings.brokerHostname);

    return;
  }

  if (argName.equalsIgnoreCase("systemHostname")) {
    response->printf("systemHostname: %s\n", systemSettings.systemHostname);

    return;
  }
  
  if (argName.equalsIgnoreCase("timeServer1")) {
    response->printf("timeServer1: %s\n", systemSettings.timeServer1);

    return;
  }
  
  if (argName.equalsIgnoreCase("timeServer2")) {
    response->printf("timeServer2: %s\n", systemSettings.timeServer2);

    return;
  }
  
  if (argName.equalsIgnoreCase("timeServer3")) {
    response->printf("timeServer3: %s\n", systemSettings.timeServer3);

    return;
  }

  if (argName.equalsIgnoreCase("sensorLocation")) {
    SparkFun_AS3935 rawSensor = sensor.getSensor();
    sensorSettings.sensorLocation = rawSensor.readIndoorOutdoor();

    switch (sensorSettings.sensorLocation)
    {
      case INDOOR:
        response->println("sensorLocation: INDOOR");
        break;
      case OUTDOOR:
        response->println("sensorLocation: OUTDOOR");
      default:
        response->printf("Invalid Setting! sensorLocation: %#x");
        break;
    }

    return;
  }

  if (argName.equalsIgnoreCase("tuningCapacitor")) {
    SparkFun_AS3935 rawSensor = sensor.getSensor();
    sensorSettings.tuningCapacitor = rawSensor.readTuneCap();

    response->printf("tuningCapacitor: %upF\n", sensorSettings.tuningCapacitor);

    return;
  }

  if (argName.equalsIgnoreCase("lightningThreshold")) {
    SparkFun_AS3935 rawSensor = sensor.getSensor();
    sensorSettings.lightningThreshold = rawSensor.readLightningThreshold();

    response->printf("lightningThreshold: %u\n", sensorSettings.lightningThreshold);

    return;
  }

  if (argName.equalsIgnoreCase("watchdogThreshold")) {
    SparkFun_AS3935 rawSensor = sensor.getSensor();
    sensorSettings.watchdogThreshold = rawSensor.readWatchdogThreshold();

    response->printf("watchdogThreshold: %u\n", sensorSettings.watchdogThreshold);

    return;
  }

  if (argName.equalsIgnoreCase("noiseFloor")) {
    SparkFun_AS3935 rawSensor = sensor.getSensor();
    sensorSettings.noiseFloor = rawSensor.readNoiseLevel();

    response->printf("noiseFloor: %u\n", sensorSettings.noiseFloor);

    return;
  }

  if (argName.equalsIgnoreCase("spikeRejection") == 1) {
    SparkFun_AS3935 rawSensor = sensor.getSensor();
    sensorSettings.spikeRejection = rawSensor.readSpikeRejection();

    response->printf("spikeRejection: %u\n", sensorSettings.spikeRejection);

    return;
  }

  if (argName.equalsIgnoreCase("reportDisturber") == 1) {
    SparkFun_AS3935 rawSensor = sensor.getSensor();

    sensorSettings.reportDisturber = !((bool) rawSensor.readMaskDisturber());

    response->printf("reportDisturber: %s\n", sensorSettings.reportDisturber ? "true" : "false");

    return;
  }

  response->println("Setting name not recognized.");
}

void displayOsc(char *args, Stream *response) {
  Pair<String, String> operands = wcli.parseCommand(args);

  String argValue = operands.first();

  if (argValue.isEmpty()) {
    response->println("Missing argument <value>");
    return;
  }

  int value = argValue.toInt();

  if (value < 0 || value > 1) {
    response->println("The value argument must be 1 or 0, indicating true or false respectively.");
    return;
  }

  String argOsc = operands.second();

  if (argOsc.isEmpty()) {
    response->println("Missing argument <osc>");
  }

  int osc = argOsc.toInt();

  if (osc < 1 || osc > 3) {
    response->println("The osc argument must be between 1 and 3");
  }

  if (value == 1) {
    sensor.detachInterruptPin();
  }

  SparkFun_AS3935 rawSensor = sensor.getSensor();
  rawSensor.displayOscillator((bool) value, osc);

  if (value == 0) {
    sensor.attachInterruptPin();
  }
}

void dig(char *args, Stream *response) {
  String argVal = wcli.parseArgument(args);

  argVal.trim();

  if (argVal.length() == 0) {
    response->println("Missing argument <hostname>");
    return;
  }

  IPAddress address;
  int result = WiFi.hostByName(argVal.c_str(), address);
  if (result == 1) {
    response->printf("%s\n", address.toString());
  } else {
    response->printf("Error: %d\n", result);
  }
}
#pragma endregion

void setup()
{
  neopixelWrite(LED_BUILTIN, 0, 0, 0);
  // Initialize serial and wait for port to open:
  Serial.begin(115200);

  // pinMode(BUTTON, INPUT);
  // pinMode(STATUS_LED, OUTPUT);
  systemPreferences.load(&systemSettings);

  WiFi.hostname(systemSettings.systemHostname);

  Serial.flush(); // Only for showing the message on serial
  delay(1000);
  wcli.setCallback(new mESP32WifiCLICallbacks());

  // Enter your custom commands:
  wcli.add("reboot", &reboot, "\tperform a ESP32 reboot");
  wcli.add("date", &printCurrentDate, "\t\tprint date and time from the system clock");
  wcli.add("clear", &clearStorage, "\t\tClear non-volatile storage.");
  wcli.add("set", &setSetting, "\t\t<name> <value> Set lightning sensor setting.");
  wcli.add("get", &getSetting, "\t\t<name> Get lightning sensor setting.");
  wcli.add("save", &saveSettings, "\tSave sensor settings to non-volitile storage.");
  wcli.add("displayOsc", &displayOsc, "\t<value> <osc>");
  wcli.add("dig", &dig, "\t<hostname> Lookup a hostname");

  wcli.shell->clear();
  // Connect to WPA/WPA2 network
  wcli.shell->attachLogo(logo);
  wcli.begin();
  if (wcli.isTelnetRunning()) wcli.shellTelnet->attachLogo(logo);

  /*
    https://learn.adafruit.com/adafruit-esp32-feather-v2/pinouts#stemma-qt-connector-3112257

    At the top-left corner of the ESP32 module, is a STEMMA QT connector, labeled QT I2C on the silk.
    This connector allows you to connect a variety of sensors and breakouts with STEMMA QT connectors using various associated cables.

    You must enable the NEOPIXEL_I2C_POWER pin (GPIO 2) for the STEMMA QT connector power to work. Set it to be an output and HIGH in your code.

    There is a NEOPIXEL_I2C_POWER (GPIO 2) pin that must be set to an output and HIGH for the STEMMA QT connector power to work.
    For running in low power mode, you can disable (set output and LOW) the NEOPIXEL_I2C_POWER pin,
    this will turn off the separate 3.3V regulator that powers the QT connector's red wire
  */

  sensorPreferences.load(&sensorSettings);

  if (!sensor.begin(sensorSettings)) {
    setErrorStatus(true);
  }

  // Run HomeAssistant discovery every minute.
  timer.every(60000, discovery);
}

void loop()
{
  checkSensor();
  mqtt.loop();
  timer.tick();
  wcli.loop();
}
